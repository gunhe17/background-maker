<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Random Shapes - Canvas</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%;
      height: 100%;
      background: #0a0a1a;
      overflow: hidden;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
    .controls {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 10;
    }
    button {
      padding: 10px 24px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(255,255,255,0.08);
      color: #fff;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      backdrop-filter: blur(10px);
      transition: background 0.2s;
    }
    button:hover {
      background: rgba(255,255,255,0.15);
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div class="controls">
    <button id="btnGenerate">Generate New Shapes</button>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    function resize() {
      canvas.width = window.innerWidth * devicePixelRatio;
      canvas.height = window.innerHeight * devicePixelRatio;
      ctx.scale(devicePixelRatio, devicePixelRatio);
    }
    window.addEventListener('resize', () => { resize(); generate(); });
    resize();

    const palettes = [
      ['#7c7cff', '#3b82f6', '#a855f7', '#22d3ee', '#f472b6'],
      ['#f97316', '#eab308', '#ef4444', '#ec4899', '#a855f7'],
      ['#10b981', '#06b6d4', '#3b82f6', '#8b5cf6', '#22d3ee'],
    ];

    // --- Random blob shape using cubic bezier curves ---
    function generateBlobPoints(cx, cy, radius, numPoints) {
      const points = [];
      const angleStep = (Math.PI * 2) / numPoints;
      for (let i = 0; i < numPoints; i++) {
        const angle = angleStep * i;
        const r = radius * (0.6 + Math.random() * 0.8);
        points.push({
          x: cx + Math.cos(angle) * r,
          y: cy + Math.sin(angle) * r,
        });
      }
      return points;
    }

    function drawBlob(ctx, points, color, alpha) {
      const len = points.length;
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = color;
      ctx.beginPath();

      // Smooth closed curve through points using Catmull-Rom -> cubic bezier
      for (let i = 0; i < len; i++) {
        const p0 = points[(i - 1 + len) % len];
        const p1 = points[i];
        const p2 = points[(i + 1) % len];
        const p3 = points[(i + 2) % len];

        if (i === 0) {
          ctx.moveTo(p1.x, p1.y);
        }

        const cp1x = p1.x + (p2.x - p0.x) / 6;
        const cp1y = p1.y + (p2.y - p0.y) / 6;
        const cp2x = p2.x - (p3.x - p1.x) / 6;
        const cp2y = p2.y - (p3.y - p1.y) / 6;

        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
      }

      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    // --- Spiky / star-like random shape ---
    function drawSpiky(ctx, cx, cy, innerR, outerR, spikes, color, alpha) {
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = color;
      ctx.beginPath();
      const step = Math.PI / spikes;
      const rotOffset = Math.random() * Math.PI * 2;
      for (let i = 0; i < spikes * 2; i++) {
        const r = i % 2 === 0
          ? outerR * (0.8 + Math.random() * 0.4)
          : innerR * (0.6 + Math.random() * 0.8);
        const angle = rotOffset + step * i;
        const x = cx + Math.cos(angle) * r;
        const y = cy + Math.sin(angle) * r;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    // --- Random polygon ---
    function drawPolygon(ctx, cx, cy, radius, sides, color, alpha) {
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = color;
      ctx.beginPath();
      const rotOffset = Math.random() * Math.PI * 2;
      for (let i = 0; i < sides; i++) {
        const angle = rotOffset + (Math.PI * 2 / sides) * i;
        const r = radius * (0.7 + Math.random() * 0.6);
        const x = cx + Math.cos(angle) * r;
        const y = cy + Math.sin(angle) * r;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    // --- Main generation ---
    let shapes = [];

    function createShapes() {
      const w = window.innerWidth;
      const h = window.innerHeight;
      const palette = palettes[Math.floor(Math.random() * palettes.length)];
      const count = 8 + Math.floor(Math.random() * 8); // 8~15 shapes
      shapes = [];

      for (let i = 0; i < count; i++) {
        const cx = Math.random() * w;
        const cy = Math.random() * h;
        const radius = 40 + Math.random() * 180;
        const color = palette[Math.floor(Math.random() * palette.length)];
        const alpha = 0.15 + Math.random() * 0.5;
        const type = Math.random();

        if (type < 0.5) {
          // Blob
          const numPoints = 5 + Math.floor(Math.random() * 6);
          shapes.push({ kind: 'blob', points: generateBlobPoints(cx, cy, radius, numPoints), color, alpha });
        } else if (type < 0.75) {
          // Spiky
          const spikes = 4 + Math.floor(Math.random() * 8);
          shapes.push({ kind: 'spiky', cx, cy, innerR: radius * 0.4, outerR: radius, spikes, color, alpha });
        } else {
          // Polygon
          const sides = 3 + Math.floor(Math.random() * 6);
          shapes.push({ kind: 'polygon', cx, cy, radius, sides, color, alpha });
        }
      }
    }

    function drawAll() {
      const w = window.innerWidth;
      const h = window.innerHeight;
      ctx.clearRect(0, 0, w, h);

      // Optional: soft glow via shadow
      ctx.shadowBlur = 40;

      for (const s of shapes) {
        ctx.shadowColor = s.color;
        if (s.kind === 'blob') {
          drawBlob(ctx, s.points, s.color, s.alpha);
        } else if (s.kind === 'spiky') {
          drawSpiky(ctx, s.cx, s.cy, s.innerR, s.outerR, s.spikes, s.color, s.alpha);
        } else {
          drawPolygon(ctx, s.cx, s.cy, s.radius, s.sides, s.color, s.alpha);
        }
      }

      ctx.shadowBlur = 0;
    }

    // --- Simple float animation ---
    let animFrame;
    let time = 0;
    const baseShapes = [];

    function animate() {
      time += 0.005;
      const w = window.innerWidth;
      const h = window.innerHeight;
      ctx.clearRect(0, 0, w, h);
      ctx.shadowBlur = 40;

      for (let i = 0; i < shapes.length; i++) {
        const s = shapes[i];
        const offsetX = Math.sin(time + i * 1.3) * 30;
        const offsetY = Math.cos(time + i * 0.9) * 25;
        const scaleF = 1 + Math.sin(time + i * 0.7) * 0.08;

        ctx.save();
        ctx.shadowColor = s.color;

        if (s.kind === 'blob') {
          const movedPoints = s.points.map(p => ({
            x: p.x + offsetX,
            y: p.y + offsetY,
          }));
          // Simple scale around centroid
          const centroid = movedPoints.reduce((acc, p) => ({ x: acc.x + p.x, y: acc.y + p.y }), { x: 0, y: 0 });
          centroid.x /= movedPoints.length;
          centroid.y /= movedPoints.length;
          const scaled = movedPoints.map(p => ({
            x: centroid.x + (p.x - centroid.x) * scaleF,
            y: centroid.y + (p.y - centroid.y) * scaleF,
          }));
          drawBlob(ctx, scaled, s.color, s.alpha);
        } else if (s.kind === 'spiky') {
          ctx.translate(offsetX, offsetY);
          ctx.translate(s.cx, s.cy);
          ctx.scale(scaleF, scaleF);
          ctx.translate(-s.cx, -s.cy);
          drawSpiky(ctx, s.cx, s.cy, s.innerR, s.outerR, s.spikes, s.color, s.alpha);
        } else {
          ctx.translate(offsetX, offsetY);
          ctx.translate(s.cx, s.cy);
          ctx.scale(scaleF, scaleF);
          ctx.translate(-s.cx, -s.cy);
          drawPolygon(ctx, s.cx, s.cy, s.radius, s.sides, s.color, s.alpha);
        }
        ctx.restore();
      }

      ctx.shadowBlur = 0;
      animFrame = requestAnimationFrame(animate);
    }

    function generate() {
      createShapes();
      if (animFrame) cancelAnimationFrame(animFrame);
      animate();
    }

    document.getElementById('btnGenerate').addEventListener('click', generate);

    generate();
  </script>
</body>
</html>